
#include "bgfx_compute.sh"

uniform vec4 _Size;

BUFFER_RO(_VelocityIn, vec4, 0);

BUFFER_WR(_VelocityOut, vec4, 1);

BUFFER_RO(_Vorticity, vec4, 2);

uniform vec4 _ElapsedTime;

uniform vec4 _VorticityScale;

uvec4 GetNeighbours(vec4 pos, vec4 size)
{
    uvec4 result;
    int maxX = size.x - 1;
    int maxY = size.y - 1;
    result.x = uint(pos.y) * _Size.x + uint(clamp(pos.x - 1, 0, maxX));
    result.y = uint(pos.y) * _Size.x + uint(clamp(pos.x + 1, 0, maxX));
    result.z = uint(clamp(pos.y - 1, 0, maxY) * size.x + pos.x);
    result.w = uint(clamp(pos.y + 1, 0, maxY) * size.x + pos.x);
    return result;
}

#define GROUP_SIZE 512

NUM_THREADS(GROUP_SIZE, 1, 1)
void main()
{
    if (gl_GlobalInvocationID.x >= _Size.x || gl_GlobalInvocationID.y >= _Size.y)
    {
        return;
    }
    uint pos = gl_GlobalInvocationID.y * _Size.x + gl_GlobalInvocationID.x;
    uvec4 n = GetNeighbours(vec4(gl_GlobalInvocationID.xy, 0, 0), _Size);
    vec4 vL = _Vorticity[n.x];
    vec4 vR = _Vorticity[n.y];
    vec4 vB = _Vorticity[n.z];
    vec4 vT = _Vorticity[n.w];
    vec4 vC = _Vorticity[pos];
    vec2 force = 0.5f * vec2(abs(vT.x) - abs(vB.x), abs(vR.x) - abs(vL.x));
    float EPSILON = 2.4414e-4f;
    float magSqr = max(EPSILON, dot(force, force));
    force = force * inversesqrt(magSqr);
    force *= _VorticityScale.x * vC * vec2(1, -1);
    vec2 final_force = force * _ElapsedTime.x;
    _VelocityOut[pos] = _VelocityIn[pos] + vec4(final_force.x, final_force.y, 0.0f, 0.0f);
}

