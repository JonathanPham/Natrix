
#version 430

layout(local_size_x = {% NUM_THREADS %}, local_size_y = {% NUM_THREADS %}, local_size_z = 1) in;

uniform uvec2 _Size;

layout(std430, binding={% VELOCITY_IN %}) buffer xst__VelocityIn
{
    vec2 _VelocityIn[];
};

layout(std430, binding={% VELOCITY_OUT %}) buffer xst__VelocityOut
{
    vec2 _VelocityOut[];
};

layout(std430, binding={% OBSTACLES %}) buffer xst__Obstacles
{
    vec2 _Obstacles[];
};

uniform float _ElapsedTime;

uniform float _Speed;

uniform float _Dissipation;

void main()
{
    if (gl_GlobalInvocationID.x >= _Size.x || gl_GlobalInvocationID.y >= _Size.y)
    {
        return;
    }
    const uint pos = gl_GlobalInvocationID.y * _Size.x + gl_GlobalInvocationID.x;
    const vec2 obstacle = _Obstacles[pos];
    if (obstacle.x > 0.0f || obstacle.y > 0.0f)
    {
        _VelocityOut[pos] = vec2(0, 0);
    }
    else
    {
        const vec2 vel = _VelocityIn[pos];
        const vec2 final_pos = vec2(float(gl_GlobalInvocationID.x) - vel.x * _ElapsedTime * _Speed, float(gl_GlobalInvocationID.y) - vel.y * _ElapsedTime * _Speed);
        const ivec2 zero = ivec2(0, 0);
        const ivec2 SizeBounds = ivec2(_Size.x - 1u, _Size.y - 1u);
        const ivec2 top_right = ivec2(clamp(ceil(final_pos), vec2(zero), vec2(SizeBounds)));
        const ivec2 bottom_left = ivec2(clamp(floor(final_pos), vec2(zero), vec2(SizeBounds)));
        const vec2 delta = final_pos - vec2(bottom_left);
        const vec2 lt = _VelocityIn[uint(top_right.y) * _Size.x + uint(bottom_left.x)];
        const vec2 rt = _VelocityIn[uint(top_right.y) * _Size.x + uint(top_right.x)];
        const vec2 lb = _VelocityIn[uint(bottom_left.y) * _Size.x + uint(bottom_left.x)];
        const vec2 rb = _VelocityIn[uint(bottom_left.y) * _Size.x + uint(top_right.x)];
        const vec2 h1 = mix(lt, rt, vec2(delta.x));
        const vec2 h2 = mix(lb, rb, vec2(delta.x));
        _VelocityOut[pos] = clamp(mix(h2, h1, vec2(delta.y)) * _Dissipation, vec2(-1.0, -1.0), vec2(1.0, 1.0));
    }
}

