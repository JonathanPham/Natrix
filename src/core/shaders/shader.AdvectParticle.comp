#version 430

layout(local_size_x = {{ NUM_THREADS }}, local_size_y = {{ NUM_THREADS }}, local_size_z = 1) in;

layout(std430, binding={{ PARTICLES_IN }}) buffer xst__ParticlesIn
{
    float _ParticlesIn[];
};

layout(std430, binding={{ PARTICLES_OUT }}) buffer xst__ParticlesOut
{
    float _ParticlesOut[];
};

uniform uvec2 _ParticleSize;

layout(std430, binding={{ VELOCITY_IN }}) buffer xst__Velocity
{
    vec2 _Velocity[];
};

layout(std430, binding={{ OBSTACLES }}) buffer xst__Obstacles
{
    vec2 _Obstacles[];
};

uniform uvec2 _VelocitySize;

uniform float _Dissipation;

uniform float _ElapsedTime;

uniform float _Speed;

vec2 GetVelocity(vec2 fPos)
{
    const ivec2 zero = ivec2(0, 0);
    const ivec2 SizeBounds = ivec2(_VelocitySize.x - 1u, _VelocitySize.y - 1u);
    const ivec2 top_right = ivec2(clamp(ceil(fPos), vec2(zero), vec2(SizeBounds)));
    const ivec2 bottom_left = ivec2(clamp(floor(fPos), vec2(zero), vec2(SizeBounds)));
    const vec2 delta = fPos - vec2(bottom_left);
    const vec2 lt = _Velocity[uint(top_right.y) * _VelocitySize.x + uint(bottom_left.x)];
    const vec2 rt = _Velocity[uint(top_right.y) * _VelocitySize.x + uint(top_right.x)];
    const vec2 lb = _Velocity[uint(bottom_left.y) * _VelocitySize.x + uint(bottom_left.x)];
    const vec2 rb = _Velocity[uint(bottom_left.y) * _VelocitySize.x + uint(top_right.x)];
    const vec2 h1 = mix(lt, rt, vec2(delta.x));
    const vec2 h2 = mix(lb, rb, vec2(delta.x));
    return mix(h2, h1, vec2(delta.y)) * (vec2(_ParticleSize) / vec2(_VelocitySize));
}

void main()
{
    if (gl_GlobalInvocationID.x >= _ParticleSize.x || gl_GlobalInvocationID.y >= _ParticleSize.y)
    {
        return;
    }

    const uint particle_pos = gl_GlobalInvocationID.y * _ParticleSize.x + gl_GlobalInvocationID.x;
    const vec2 fNormalisedPos = vec2(float(gl_GlobalInvocationID.x) / float(_ParticleSize.x), float(gl_GlobalInvocationID.y) / float(_ParticleSize.y)) * vec2(_VelocitySize);
    const uint obstacle_pos = (uint(fNormalisedPos.y)) * _VelocitySize.x + (uint(fNormalisedPos.x));
    const vec2 obstacle = _Obstacles[obstacle_pos];

    if (obstacle.x > 0.0f || obstacle.y > 0.0f)
    {
        _ParticlesOut[particle_pos] = 0.0f;
    }
    else
    {
        const vec2 vel = GetVelocity(fNormalisedPos);
        const vec2 final_pos = vec2(float(gl_GlobalInvocationID.x) - vel.x * _ElapsedTime * _Speed, float(gl_GlobalInvocationID.y) - vel.y * _ElapsedTime * _Speed);
        const ivec2 zero = ivec2(0, 0);
        const ivec2 SizeBounds = ivec2(_ParticleSize.x - 1u, _ParticleSize.y - 1u);
        const ivec2 top_right = ivec2(clamp(ceil(final_pos), vec2(zero), vec2(SizeBounds)));
        const ivec2 bottom_left = ivec2(clamp(floor(final_pos), vec2(zero), vec2(SizeBounds)));
        const vec2 delta = final_pos - vec2(bottom_left);
        const float lt = _ParticlesIn[uint(top_right.y) * _ParticleSize.x + uint(bottom_left.x)];
        const float rt = _ParticlesIn[uint(top_right.y) * _ParticleSize.x + uint(top_right.x)];
        const float lb = _ParticlesIn[uint(bottom_left.y) * _ParticleSize.x + uint(bottom_left.x)];
        const float rb = _ParticlesIn[uint(bottom_left.y) * _ParticleSize.x + uint(top_right.x)];
        const float h1 = mix(lt, rt, delta.x);
        const float h2 = mix(lb, rb, delta.x);
        _ParticlesOut[particle_pos] = mix(h2, h1, delta.y) * _Dissipation;
    }
}
